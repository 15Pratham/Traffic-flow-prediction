# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mMUDakHpoWsNbBNKVKOp66Qeh5O49_GK
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
df = pd.read_csv("/content/traffic_prediction_extended.csv")
df

df.describe()

print("📄 Original Data Info:")
print(df.info())
print("\n🧼 First 5 rows:")
print(df.head())
df['Timestamp'] = pd.to_datetime(df['Timestamp'], errors='coerce')
df['Hour'] = df['Timestamp'].dt.hour
df['Day'] = df['Timestamp'].dt.day
df['DayOfWeek'] = df['Timestamp'].dt.dayofweek
df['Month'] = df['Timestamp'].dt.month
df.dropna(inplace=True)
print("\n✅ Preprocessing done")

before = df.shape[0]
df.drop_duplicates(inplace=True)
after = df.shape[0]
print(f"✅ Removed {before - after} duplicate rows.")

print("\n📊 Descriptive stats:")
print(df.describe())
print("\n❓ Missing Values:")
print(df.isnull().sum())
df.to_csv("cleaned_traffic_data.csv", index=False)
print("✅ Cleaned data saved as 'cleaned_traffic_data.csv'")

# UNIVARIATE ANALYSIS
plt.figure(figsize=(6, 4))
sns.histplot(df['Vehicle_Count'], kde=True, color='skyblue')
plt.title("Distribution of Vehicle Count")
plt.show()
plt.figure(figsize=(6, 4))
sns.countplot(x='Weather_Condition', data=df)
plt.title("Weather Condition Frequency")
plt.show()

# BIVARIATE ANALYSIS
plt.figure(figsize=(6, 4))
sns.scatterplot(x='Traffic_Speed', y='Vehicle_Count', hue='Accident_Occurred', data=df)
plt.title("Traffic Speed vs Vehicle Count")
plt.show()
plt.figure(figsize=(6, 4))
sns.boxplot(x='Road_Type', y='Traffic_Density', data=df)
plt.title("Traffic Density by Road Type")
plt.show()

# MULTIVARIATE ANALYSIS
sns.pairplot(df[['Vehicle_Count', 'Traffic_Speed', 'Traffic_Density', 'Accident_Occurred']])
plt.suptitle("Multivariate Pairwise Plot", y=1.02)
plt.show()

# CORRELATION & COVARIANCE
plt.figure(figsize=(10, 6))
sns.heatmap(numeric_df.corr(), annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Correlation Matrix")
plt.show()

numeric_df = df.select_dtypes(include=['number'])
print("\n📈 Covariance Matrix:")
print(numeric_df.cov())

df = df[['Traffic_Speed', 'Vehicle_Count']].dropna()
X = df['Traffic_Speed'].values.reshape(-1, 1)
y = df['Vehicle_Count'].values.reshape(-1, 1)
model = LinearRegression()
model.fit(X, y)
m = model.coef_[0][0]
b = model.intercept_[0]

print(f"✅ Linear Regression Equation: y = {m:.2f}x + {b:.2f}")
plt.figure(figsize=(8, 5))
plt.scatter(X, y, color='blue', alpha=0.5, label='Data Points')
plt.plot(X, model.predict(X), color='red', linewidth=2, label='Regression Line')
plt.title('Vehicle Count vs Traffic Speed')
plt.xlabel('Traffic Speed')
plt.ylabel('Vehicle Count')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

features = ['Traffic_Speed', 'Traffic_Density']
target = 'Vehicle_Count'

df = df[features + [target]].dropna()

X = df[features]
y = df[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LinearRegression()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print(f"✅ R² Score: {r2:.4f}")
print(f"📉 MSE: {mse:.2f}")
print(f"📉 RMSE: {rmse:.2f}")

import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

df_numeric = df.select_dtypes(include=['number']).dropna()
scaler = StandardScaler()
scaled_data = scaler.fit_transform(df_numeric)
pca = PCA(n_components=2)
pca_data = pca.fit_transform(scaled_data)
pca_df = pd.DataFrame(data=pca_data, columns=['PC1', 'PC2'])
plt.figure(figsize=(8, 6))
plt.scatter(pca_df['PC1'], pca_df['PC2'], alpha=0.5, c='blue')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.title('PCA - 2D Projection')
plt.grid(True)
plt.tight_layout()
plt.show()
print("🔍 Explained Variance Ratio by PC1 and PC2:")
print(pca.explained_variance_ratio_)

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Ridge, Lasso
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
features = ['Traffic_Speed', 'Traffic_Density']
target = 'Vehicle_Count'
df = df[features + [target]].dropna()

X = df[features]
y = df[target]

# Scale the features (important for regularization)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# 1️⃣ Ridge Regression (L2)
ridge = Ridge(alpha=1.0)
ridge.fit(X_train, y_train)
ridge_pred = ridge.predict(X_test)

print("📘 Ridge Regression (L2)")
print(f"R² Score: {r2_score(y_test, ridge_pred):.4f}")
print(f"MSE: {mean_squared_error(y_test, ridge_pred):.2f}")
print(f"Coefficients: {ridge.coef_}")

# 2️⃣ Lasso Regression (L1)
lasso = Lasso(alpha=0.1)
lasso.fit(X_train, y_train)
lasso_pred = lasso.predict(X_test)

print("\n📕 Lasso Regression (L1)")
print(f"R² Score: {r2_score(y_test, lasso_pred):.4f}")
print(f"MSE: {mean_squared_error(y_test, lasso_pred):.2f}")
print(f"Coefficients: {lasso.coef_}")

df = df[['Traffic_Speed', 'Vehicle_Count']].dropna()
X = df['Traffic_Speed'].values
y = df['Vehicle_Count'].values
m = 0
b = 0
alpha = 0.0001
n = len(X)
y_pred = m * X + b
dm = -(2/n) * np.sum(X * (y - y_pred))
db = -(2/n) * np.sum(y - y_pred)

m = m - alpha * dm
b = b - alpha * db

print(f"📉 Updated m after 1 step: {m:.4f}")
print(f"📉 Updated b after 1 step: {b:.4f}")

features = ['Traffic_Speed', 'Traffic_Density']
target = 'Vehicle_Count'
df = df[features + [target]].dropna()

X = df[features]
y = df[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
model = xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1, max_depth=4)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"📊 XGBoost Results:")
print(f"✅ MSE: {mse:.2f}")
print(f"✅ R² Score: {r2:.4f}")
xgb.plot_importance(model)
plt.title("Feature Importance - XGBoost")
plt.show()

from sklearn.metrics import mean_squared_error, r2_score
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)


print("📊 Model Evaluation Metrics:")
print(f"🔹 MSE  = {mse:.2f}")
print(f"🔹 RMSE = {rmse:.2f}")
print(f"🔹 R²   = {r2:.4f}")
plt.figure(figsize=(10, 6))
plt.plot(y_test.values[:50], label='Actual', marker='o')
plt.plot(y_pred[:50], label='Predicted', marker='x')
plt.title("🔍 Actual vs Predicted Vehicle Count")
plt.xlabel("Sample Index")
plt.ylabel("Vehicle Count")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import pandas as pd
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import xgboost as xgb
df = pd.read_csv("cleaned_traffic_data.csv")
df = df[['Traffic_Speed', 'Traffic_Density', 'Vehicle_Count']].dropna()

X = df[['Traffic_Speed', 'Traffic_Density']]
y = df['Vehicle_Count']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
models = {
    'Linear Regression': LinearRegression(),
    'Ridge Regression': Ridge(alpha=1.0),
    'Lasso Regression': Lasso(alpha=0.1),
    'XGBoost': xgb.XGBRegressor(objective='reg:squarederror', n_estimators=100, learning_rate=0.1)
}
results = []

for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    r2 = r2_score(y_test, y_pred)
    results.append((name, rmse, r2))
print("📊 Cross-Model Comparison (on Test Set):")
for name, rmse, r2 in results:
    print(f"{name:<20} | RMSE: {rmse:.2f} | R²: {r2:.4f}")

model_names = [r[0] for r in results]
rmse_values = [r[1] for r in results]
r2_values = [r[2] for r in results]

plt.figure(figsize=(10, 5))
plt.bar(model_names, rmse_values, color='skyblue')
plt.title("RMSE Comparison Across Models")
plt.ylabel("RMSE")
plt.grid(True, axis='y')
plt.xticks(rotation=15)
plt.tight_layout()
plt.show()